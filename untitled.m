%% Cleaning and Initialization
close all
clear
clc

%% Load and Process Data

%%% evaluating in 288 hours (24 * 12 days)
deltaT = 0.5;   % half an hour
Time = 0:deltaT:24;
num_days = 12;
Time_day = 0:deltaT:24;
hours_per_day = 24;
total_hours = num_days * hours_per_day; % 288 hours

% Load Irradiance and Temperature Data
A = readmatrix('dailydata12monthsaverage.csv');
Pirr_data = reshape(A(:,2), [hours_per_day*num_days, 1]); %changing the dimension without changing the data and reshaping it into data and time
Temp_data = reshape(A(:,3), [hours_per_day*num_days, 1]); 
Time_data = 0:total_hours-1; 
Pirr_data(25) = Pirr_data(1);  
Temp_data(25) = 0.5*(Temp_data(24)+Temp_data(1)); 

%%interporlation and plot
Pirr = interp1(Time_data, Pirr_data, Time, 'linear', 'extrap');
Temp = interp1(Time_data, Temp_data, Time, 'linear', 'extrap');
%% 

% Load Wind Speed Data
A = readmatrix('wind_speed.txt');
w_speed = reshape(A(:,1), [288, 1]);
w_speed = reshape(A(:,1), [hours_per_day*num_days, 1]);
w_speed(25) = w_speed(1); %Ensures periodicity by making the 25th value equal to the 1st
Time = 0:length(w_speed)-1; % time vector for wind speed data.

%% 

% Load Profile Data Processing
P_load_day = load('load3.txt'); 
year = 10
load_growth = 0.025; %growtth of load by year is 25%
P_load = (reshape (P_load_day, [], 1)) * ((1+load_growth)^year);


%% 
% system specific information

%PV System
 P_PV_STC = 485 
 G_STC = 1000
 CT = -0.0029; 
 T_STC = 25;
 eta_PV = 0.99;
 P_area = 2.163; 
 r_deg = 0.004448

 Cinv_PV = 0.14857;   % € / W 
 Cinv_panel = Cinv_PV*P_PV_STC;

GSR = Pirr_data;    % W/m^2
T_PV = Temp_data;   % celsius degrees
%% 

%Battery System
C_cell = 4560; %capacity of one cell 
eta_bat = 0.97; %efficiency of battery
eta_DCDC = 0.985; %Efficiency of DC-DC Converter
eta_ACDC = 0.988 %Efficiency of AC-DC Converer
eta_DCDCw = 0.985 %Efficiency of wind turbine AC-DC

Cinv_bat = 255.39;   % € / kWh
Cinv_cell = Cinv_bat*1e-3*C_cell;



%% 
%wind system 
vci = 2.5; % Cut-in wind speed (m/s)
vr = 10; % Rated wind speed (m/s)
P_turb = 2000; % Rated power output of wind turbine (W)
eta_turb = 0.92; % Wind turbine efficiency
Cinv_turb = P_turb*0.6235;

%Space constraint
A_total = 17596.62 * 0.89 %space required for the renewable energy space
A_usable = A_total;
D_turbine = 1.9; %Diameter of a wind trubine rotor (m)
A_turbine = pi * (D_turbine/2)^2 %swept area of the wind turbine
spacing_factor = 8; %minimum distance required between the turbines
A_required_per_turbine = spacing_factor * (D_turbine^2); %land reauired per turbine
P_area = 2.163; 
Npv_min = 1;    % minimal number of panels

%% Total energy consumed by the load in on day
E_load = sum(P_load)*deltaT;          % one day energy of the load

% Total energy generated by the paned in one day
E_panel = sum(comp_P_PV(1,P_PV_STC,G_STC,CT,T_STC,eta_PV,GSR,T_PV,year,r_deg))*deltaT;   
                    % one day energy of one single panel
% X = ( Npv, Ncell, SOC_ini, )
%% Defining Cost

% Cost and Economic Analysis
year = 10;% 
OPEX_PV_per_kWp = 5.64; % Operational costs per kW per year for PV
OPEX_Battery_per_kWh = 15.64; % Operational costs per kWh per year for battery
OPEX_Wind_per_kW = 32.2; % Operational costs per kW per year for wind
OPEX_PV_total = OPEX_PV_per_kWp * (P_PV_STC / 1000) * year; %calculates the total operating cost over a period of 10 years
OPEX_Battery_total = OPEX_Battery_per_kWh * (C_cell / 1000) * year; %calculates the total cost of maintaining and operating the battery storage system over its entire lifespan
OPEX_Wind_total = OPEX_Wind_per_kW * (P_turb / 1000) * year; %calculates the total operational cost of running the wind turbines over a period of 10 years

%% 
%Defining functions

%Defining function for PV
function P_PV = comp_P_PV (Npv,P_PV_STC,G_STC,CT,T_STC,eta_PV,GSR,T_PV,year,r_deg) %calling the pv functions for the pv panel

        P_PV = (Npv * eta_PV * P_PV_STC / G_STC * (1 + CT * (T_PV - T_STC)) .* GSR) * (1 - r_deg)^(year - 1); %Modeling the pv generator output
end

%Defining function for wind turbine
function P_wind = comp_P_wind(Nturb, w_speed, vr, vci, P_turb) %calling function for the wind
   
    A = (1 ./ ((vci - vr).^2)) .* (vci .* (vci + vr) - 4 .* vci .* vr .* (((vci + vr) ./ (2 .* vr)).^3));
    B = (1 ./ ((vci - vr).^2)) .* (4 .* (vci + vr) .* (((vci + vr) ./ (2 .* vr)).^3) - (3 .* vci + vr));
    C = (1 ./ ((vci - vr).^2)) .* (2 - 4 .* (((vci + vr) ./ (2 .* vr)).^3));
    P_wind = Nturb .* (A + (B .* w_speed) + (C .* (w_speed).^2)) .* P_turb; %calculating the p wind
    P_wind(P_wind < 0) = 0; %basically assigning the value 0 to the power of wind if its ever negative return
end

%%     %% 
    function [P_pv, P_wind, P_bat, SOC, P_lost, P_unsup] = comp_Power(Npv, Nturb, Ncell, SOC_ini, ...
            deltaT, P_load, eta_DCDC, eta_ACDC, eta_bat, C_cell, SOC_min, SOC_max, ...
            P_PV_STC, G_STC, CT, T_STC, eta_PV, GSR, T_PV, year, r_deg, ...
            w_speed, vr, vci, P_turb,eta_ACDCw)

    % compute the powers in the different elements
    P_wind = comp_P_wind(Nturb, w_speed, vr, vci, P_turb); %calculates the wind power
    P_pv = comp_P_PV(Npv,P_PV_STC,G_STC,CT,T_STC,eta_PV,GSR,T_PV,year,r_deg); %calculates the pv wind
    
    n = length(P_pv); %number of pv panel values
    P_unsup = zeros(1,n); %energy value for unsuppied power
    P_bat =  zeros(1,n); %energy value for battery
    P_lost = zeros(1,n); %energy value for lost power
    SOC = zeros(1,n+1); %soc of the battery
    SOC(1) = SOC_ini;%set % Initial state of charge (SOC) set to SOC_ini
    
    for k = 1:n %Loop over each solar panel or each time step

        P_total = eta_DCDC * (P_pv(k)) + eta_ACDCw*P_wind(k);  % Available power from both the pv and wind

        if P_total >= P_load(k) / eta_ACDC  % Excess energy case
            if SOC(k) < SOC_max % If the battery isn't fully charged
                P_bat(k) = -eta_DCDC * (P_total - P_load(k) / eta_ACDC); %calculated the amount of energy that would be stored in the battery

                SOC(k+1) = min(SOC(k) - eta_bat * P_bat(k) * deltaT / (Ncell * C_cell), SOC_max); % Update the battery SOC
            else
                P_lost(k) = P_total - P_load(k) / eta_ACDC; % Excess energy is lost
                SOC(k+1) = SOC(k);  % Battery remains full
            end
        else  % Deficit energy case (% Not enough power to meet the load)
            if SOC(k) > SOC_min
                P_bat(k) = -1/eta_DCDC * (P_total - P_load(k) / eta_ACDC);  % Calculating the power drawn from the battery based on the pload and ptotal
                SOC(k+1) = max(SOC(k) - P_bat(k) * deltaT / (Ncell * C_cell), SOC_min); %stating that the currnt soc should be max between amount drawn and minsoc 
           
            else %if the battery does not have any charge left
                P_unsup(k) = -(P_total - P_load(k) / eta_ACDC); %calculates the unsupplied power
                SOC(k+1) = SOC(k); %updated based on how much energy was drawn from the battery
            end
        end
    end
end

%c vector representing ineaulity constraint
%ceq vector representing equality containts 
function [c, ceq] = constraints(Npv, Nturb, Ncell, SOC_ini, ...
        deltaT, P_load, eta_DCDC, eta_ACDC, eta_bat, C_cell, SOC_min, SOC_max, ...
        P_PV_STC, G_STC, CT, T_STC, eta_PV, GSR, T_PV, year, r_deg, ...
        w_speed, vr, vci, P_turb,A_usable, P_area, A_required_per_turbine,...
        eta_ACDCw)

%computing the power unsuplied and the soc based on the control setting that was set   
    [~, ~, ~, SOC, ~, P_unsup] = comp_Power(Npv, Nturb, Ncell, SOC_ini, ...
        deltaT, P_load, eta_DCDC, eta_ACDC, eta_bat, C_cell, SOC_min, SOC_max, ...
        P_PV_STC, G_STC, CT, T_STC, eta_PV, GSR, T_PV, year, r_deg, ...
        w_speed, vr, vci, P_turb,eta_ACDCw);

    total_area_used = (Npv*P_area) + (Nturb*A_required_per_turbine);

    % Constraints
    c1 = SOC_min - min(SOC);  % Ensure SOC does not drop below min
    c2 = max(SOC) - SOC_max;  % Ensure SOC does not exceed max
    c3 = max(P_unsup);        % Ensure unmet load is minimized
    c4 = SOC(1) - SOC(end);   % Ensure initial and final SOC match
    c5 = total_area_used - A_usable; % Ensure PV + Wind do not exceed usable land

    %If any of these values is negative, the corresponding constraint is violated, and the optimization will try to adjust the variables to satisfy these constraints.
    c = [c1 c2 c3 c4 c5];
    % here there are no inequality constraints (there is nothing that must be exactly equal).
    ceq = []; 
end
%% 

%Constraints
P_load = P_load*200;
% optimization constraints 
SOC_min = 0.5; % percentatage minimum state of charge of the battery
SOC_max = 0.9; % percentage maximum state of charge of battery
Npv_max = floor (A_usable / P_area); %maximum number of pv that can be installed
Ncell_min = 10 % minmum number of batteries
Ncell_max = 1000 %maximum number of batteries
SOC_ini_min = SOC_min*100; % minimum state of charge of the battery
SOC_ini_max = SOC_max*100; % maximum state of charge of the battery
Nturb_min = 0; % minmum number of turbines
Nturb_max = floor(A_usable / A_required_per_turbine); %maximum number of wind turbine that can be installed
eta_ACDCw = 0.985;

% setting lower and upper bound
Xl = [1; Ncell_min; Nturb_min; SOC_ini_min];
Xu = [Npv_max; Ncell_max; Nturb_max; SOC_ini_max];

% objective constraints

obj = @(X) (X(1) * (Cinv_panel + OPEX_PV_total) + ...  
            X(2) * (Cinv_cell + OPEX_Battery_total) + ... 
            X(3) * (Cinv_turb + OPEX_Wind_total));

%Contraint function
% no linear constraints
% non-linear constraints are defined by a specific function : "constraints"
nlconstraints = @(X) constraints(X(1), X(2), X(3), X(4) * 1e-2, ...
    deltaT, P_load, eta_DCDC, eta_ACDC, eta_bat, C_cell, SOC_min, SOC_max, ...
    P_PV_STC, G_STC, CT, T_STC, eta_PV, GSR, T_PV, year, r_deg, ...
    w_speed, vr, vci, P_turb,A_usable, P_area, A_required_per_turbine,eta_ACDCw); %factors that cannot be expressed as linear 

% Options for ga (if needed):
options = optimoptions(@ga);
%options.Display = ('iter');
options.PopulationSize = 500; %the number of individuals (solutions) in the population
options.MaxGenerations = 10000; % the maximum number of generations
options.FunctionTolerance = 1e-12; %tolerance level mean that the algorithm will stop if the difference between solutions is smaller than this threshold.
options.ConstraintTolerance = 1e-3; %The algorithm will stop when the constraints are satisfied within the specified tolerance or if it cannot improve further while meeting these constraints.

%objective output
 % Xopt optimized solution vector 
 % cost (or objective function value)
[Xopt, cost] = ga(obj, 4, [], [], [], [], Xl, Xu, nlconstraints, [1 2 3], options)

%computing power output
[P_pv, P_wind, P_bat, SOC, P_lost, P_unsup] = comp_Power(Xopt(1), Xopt(2), Xopt(3), Xopt(4) * 1e-2, ...
    deltaT, P_load, eta_DCDC, eta_ACDC, eta_bat, C_cell, SOC_min, SOC_max, ...
    P_PV_STC, G_STC, CT, T_STC, eta_PV, GSR, T_PV, year, r_deg, ...
    w_speed, vr, vci, P_turb,eta_ACDCw);
   
%% Ploting the graphs 
%%
%ploting the graph of irradiance against time 
%we are averaging the data for each month based on the hourly data you have
figure(1)
plot(Time_data, Pirr_data, 'LineWidth', 2)
xlabel('Month')
xlim([0 287]) % Ensures the graph stops at 287
title('Irradiance Power ', 'FontSize', 14)
ylabel('Irradiation Power (W/m^2)')
grid on
xlim([0, max(Time_data)])
xticks(0:24:max(Time_data))  % Set the tick marks for each 24-hour period

% Assuming 0-288 corresponds to 12 months (1 month = 24*30 = 720 hours)
xticklabels({'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'})
ax = gca; %get current axis AND store in ax
ax.XAxis.MinorTick = 'on';
ax.XAxis.MinorTickValues = 0:6:max(Time_data);  % Set minor ticks every 6 hours

%%

%ploting the graph of temperature against time 
figure(2)
plot(Time_data, Temp_data, 'LineWidth', 2, 'Color', 'r') 
xlabel('Month', 'FontSize', 12)
ylabel('Temperature (°C)', 'FontSize', 12)
title('Average Temperature Profile Over Time', 'FontSize', 14)
grid on
%xlim([0, max(Time_data)])
%xticks(0:24:max(Time_data)) 
xlim([0, max(Time_data)])
xticks(0:24:max(Time_data))  % Set the tick marks for each 24-hour period

% Assuming 0-288 corresponds to 12 months (1 month = 24*30 = 720 hours)
xticklabels({'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'})
ax = gca;
ax.XAxis.MinorTick = 'on';
ax.XAxis.MinorTickValues = 0:6:max(Time_data);  % Set minor ticks every 6 hours

%% plot load
%we are plotting the load profile
figure(4);
plot(Time, P_load, '-', 'LineWidth', 2);
xlabel('Month');
ylabel('Load Power Profile (kW)');
title('Average Load Power Profile per Month');
grid on;
xlim([0, 288]);  % 0 to 288 hours (12 months * 24 hours)
xticks(0:24:288);  % Every 24 hours (start of each month)
xticklabels({'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'});
ax = gca;
ax.XAxis.MinorTick = 'on';
ax.XAxis.MinorTickValues = 0:1:288;  % Minor ticks every hour
% Rotate x-axis labels for better readability
xtickangle(45);
ylim auto;
%% %% the plot of wind against time
figure(5);
plot(Time, w_speed, '-', 'LineWidth', 2);
xlabel('Month');
ylabel('Wind Speed (m/s)');
title('Average Wind Speed');
grid on;
xlim([0, 288]);  % 0 to 288 hours (12 months * 24 hours)
xticks(0:24:288);  % Every 24 hours (start of each month)
xticklabels({'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'});
ax = gca;
ax.XAxis.MinorTick = 'on';
ax.XAxis.MinorTickValues = 0:1:288;  % Minor ticks every hour
xtickangle(45);
ylim auto;


%% power produce by a single panel 
Time = 0:287; % 12 days * 24 hours = 288 hours
P_PV_output2 = comp_P_PV(1, P_PV_STC, G_STC, CT, T_STC, eta_PV, Pirr_data, Temp_data,year,r_deg);
figure(3)
plot(Time, P_PV_output2, 'LineWidth', 2)
xlim([0 287]) % Ensures the graph stops at 287
xlabel('Month')
ylabel('Power Output (kW)')
grid on
title('Average PV Power Output per Month')
xlim([0, max(Time)])
xticks(0:24:max(Time))  % Set the tick marks for each 24-hour period

% Assuming 0-288 corresponds to 12 months (1 month = 24*30 = 720 hours)
xticklabels({'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'})
ax = gca;
ax.XAxis.MinorTick = 'on';
ax.XAxis.MinorTickValues = 0:6:max(Time);  % Set minor ticks every 6 hours
%% 
%% power produce by a wind turbine 
Time = 0:287; % 12 days * 24 hours = 288 hours
P_wind1=comp_P_wind(1,w_speed,vr,vci,P_turb);
figure(10)
plot(Time, P_wind1, 'LineWidth', 2)
xlim([0 287]) % Ensures the graph stops at 287
xlabel('Month')
ylabel('Power Output (kW)')
grid on
title('Average wind Output per Month')
xlim([0, max(Time)])
xticks(0:24:max(Time))  % Set the tick marks for each 24-hour period

% Assuming 0-288 corresponds to 12 months (1 month = 24*30 = 720 hours)
xticklabels({'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'})
ax = gca;
ax.XAxis.MinorTick = 'on';
ax.XAxis.MinorTickValues = 0:6:max(Time);  % Set minor ticks every 6 hours
%% overall graph power flow
figure(7)

plot(Time, P_load/1000, 'LineWidth', 2) %line plot of load and converts it from watts into kilowatts
hold on;
plot(Time, P_pv/1000, 'LineWidth', 2)
plot(Time, P_bat/1000, 'LineWidth', 2)
plot(Time, P_wind/1000, 'LineWidth', 2)
plot(Time, P_lost/1000, 'LineWidth', 2)
plot(Time, P_unsup/1000, 'LineWidth', 2)
hold off;

legend('Load', 'PV', 'Battery', 'Wind', 'Exported', 'Unsupplied', 'Location', 'bestoutside');
xlim([0, 288]);  % 0 to 288 hours (12 months * 24 hours)
xlabel('Month');
ylabel('Power (kW)');
title('System Operation per Month in a Typical Year');

xticks(0:24:288);  % Every 24 hours (start of each month)
xticklabels({'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'});
ax = gca;
ax.XAxis.MinorTick = 'on';
ax.XAxis.MinorTickValues = 0:1:288;  % Minor ticks every hour
xtickangle(45);
ylim auto;


P_lost1 = P_lost/1000;
% Example data, replace with actual P_lost1 matrix
P_lost1 = rand(12,24) / 1000; % just egenrates a random data for the power lost for the averaged hour of every month


% Define the number of days in each month
days_in_month = [31,28,31,30,31,30,31,31,30,31,30,31]; % Days in each month

% Expand P_lost1 to represent every day of the year
P_lost_expanded = [];

for month = 1:12
    % Replicate each row (month) by the number of days in that month
    daily_values = repmat(P_lost1(month, :), days_in_month(month), 1);
    % Append to the new matrix
    P_lost_expanded = [P_lost_expanded; daily_values];
end

% Save to CSV
writematrix(P_lost_expanded, 'P_lost_adjusted.csv');